'''
Created on Jun 28, 2011

@package: ally core http
@copyright: 2012 Sourcefabric o.p.s.
@license: http://www.gnu.org/licenses/gpl-3.0.txt
@author: Gabriel Nistor

Provides the URI request path handler.
'''

from ally.container.ioc import injected
from ally.core.http.spec import RequestHTTP
from ally.core.spec.codes import RESOURCE_NOT_FOUND, RESOURCE_FOUND
from ally.core.spec.resources import ConverterPath, Path, IResourcesLocator
from ally.core.spec.server import Response, Processor, ProcessorsChain, \
    EncoderPath
from urllib.parse import urlencode, urlunsplit, urlsplit
import logging

# --------------------------------------------------------------------

log = logging.getLogger(__name__)

# --------------------------------------------------------------------

@injected
class URIHandler(Processor):
    '''
    Implementation for a processor that provides the searches based on the request URL the resource path, also
    populates the parameters and extension format on the request.
    
    Provides on request: resourcePath, accContentTypes
    Provides on response: code, encoderPath
    
    Requires on request: path
    Requires on response: NA
    '''

    resourcesLocator = IResourcesLocator
    # The resources locator that will provide the path to the resource node.
    converterPath = ConverterPath
    # The converter path used for handling the URL path.
    scheme = 'http'
    # The scheme of the uri
    headerHost = 'Host'
    # The header in which the host is provided.

    def __init__(self):
        assert isinstance(self.resourcesLocator, IResourcesLocator), \
        'Invalid resources locator %s' % self.resourcesLocator
        assert isinstance(self.converterPath, ConverterPath), 'Invalid ConverterPath object %s' % self.converterPath
        assert isinstance(self.scheme, str), 'Invalid string %s' % self.scheme
        assert isinstance(self.headerHost, str), 'Invalid string %s' % self.headerHost

    def process(self, req, rsp, chain):
        '''
        @see: Processor.process
        '''
        assert isinstance(req, RequestHTTP), 'Invalid HTTP request %s' % req
        assert isinstance(rsp, Response), 'Invalid response %s' % rsp
        assert isinstance(chain, ProcessorsChain), 'Invalid processors chain %s' % chain
        assert isinstance(req.path, str), 'Invalid request path %s' % req.path

        paths = req.path.split('/')
        i = paths[-1].rfind('.') if len(paths) > 0 else -1
        if i < 0:
            extension = None
        else:
            extension = paths[-1][i + 1:].lower()
            paths[-1] = paths[-1][0:i]
        paths = [p for p in paths if p]

        rsp.encoderPath = EncoderPathURI(self.scheme, req.headers.pop(self.headerHost, ''), req.rootURI,
                                         self.converterPath, extension)
        if extension:
            rsp.contentType = extension
            req.accContentTypes.insert(0, extension)

        resourcePath = self.resourcesLocator.findPath(self.converterPath, paths)
        assert isinstance(resourcePath, Path)
        if not resourcePath.node:
            # we stop the chain processing
            rsp.setCode(RESOURCE_NOT_FOUND, 'Cannot find resources for path')
            return
        rsp.code = RESOURCE_FOUND
        req.resourcePath = resourcePath
        rsp.scheme = self.scheme
        assert log.debug('Successfully found resource for path %s with extension %s', req.path, extension) or True
        chain.proceed()

# --------------------------------------------------------------------

class EncoderPathURI(EncoderPath):
    '''
    Provides encoding for the URI paths generated by the URI processor.
    '''

    __slots__ = ('scheme', 'host', 'root', 'converterPath', 'extension')

    def __init__(self, scheme, host, root, converterPath, extension):
        '''
        @param scheme: string
            The encoded path scheme.
        @param host: string
            The host string.
        @param root: string
            The root URI to be considered for constructing a request path, basically the relative path root. None if the path
            is not relative.
        @param converterPath: ConverterPath
            The converter path to be used on Path objects to get the URL.
        @param extension: string
            The extension to use on the encoded paths.
        '''
        assert isinstance(scheme, str), 'Invalid scheme %s' % scheme
        assert isinstance(host, str), 'Invalid host %s' % host
        assert isinstance(root, str), 'Invalid root URI %s' % root
        assert isinstance(converterPath, ConverterPath), 'Invalid converter path %s' % converterPath
        assert not extension or isinstance(extension, str), 'Invalid extension %s' % extension
        self.scheme = scheme
        self.host = host
        self.root = root
        self.converterPath = converterPath
        self.extension = extension

    def encode(self, path, parameters=None):
        '''
        @see: EncoderPath.encode
        '''
        assert isinstance(path, (Path, str)), 'Invalid path %s' % path
        if isinstance(path, Path):
            assert isinstance(path, Path)
            paths = path.toPaths(self.converterPath)
            if self.extension: paths.append('.' + self.extension)
            elif path.node.isGroup: paths.append('')

            query = urlencode(parameters) if parameters else ''
            return urlunsplit((self.scheme, self.host, self.root + '/'.join(paths), query, ''))
        else:
            assert isinstance(path, str), 'Invalid path %s' % path
            if not path.strip().startswith('/'):
                #TODO: improve the relative path detection
                # This is an absolute path so we will return it as it is.
                return path
            # The path is relative to this server so we will convert it in an absolute path
            url = urlsplit(path)
            return urlunsplit((self.scheme, self.host, url.path, url.query, url.fragment))
