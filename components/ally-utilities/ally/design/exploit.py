'''
Created on May 23, 2012

@package: ally core
@copyright: 2012 Sourcefabric o.p.s.
@license: http://www.gnu.org/licenses/gpl-3.0.txt
@author: Gabriel Nistor

Provides basic meta decode implementations. 
'''

from collections import deque
import abc

# --------------------------------------------------------------------

# Statuses for the exploit nodes.
NORMAL = 1 << 1
PRIVATE = 1 << 2

# --------------------------------------------------------------------

class ResolveError(Exception):
    '''
    Exception thrown whenever there is a resolve problem.
    '''

class IResolve(metaclass=abc.ABCMeta):
    '''
    Specification for exploits resolving.
    '''
    __slots__ = ()

    @abc.abstractclassmethod
    def request(self, *path, **data):
        '''
        Push a new resolve request into this resolver, the resolve will be solved asynchronous, this means that this
        method will return before the actual resolve is performed.
        
        @param path: arguments[object]
            The path to be resolved.
        @param data: key arguments
            The data to resolve the path with.
        @return: boolean
            True if the request has been successfully queued, False if the path is not valid.
        '''

    @abc.abstractclassmethod
    def requestBatch(self, *path, data):
        '''
        '''
        #TODO: implement

    @abc.abstractclassmethod
    def has(self):
        '''
        Checks if there are any more request to be resolved.
        
        @return: boolean
            True if there are requests queued, False otherwise.
        '''

    @abc.abstractclassmethod
    def do(self):
        '''
        Proceeds with the resolve requests.
        
        @return: boolean
            True if the current resolve request has been finalized successful, False otherwise.
        '''

    @abc.abstractclassmethod
    def doAll(self):
        '''
        Process all requests. Only call this method if there are requests queued.
        
        @return: boolean
            True if all the requests have been finalized successfully, False otherwise.
        '''

class Exploit:
    '''
    Container for an exploit node.
    '''
    __slots__ = ('exploit', 'locator', 'status', 'children')

    def __init__(self, exploit=None, locator=None, status=NORMAL):
        '''
        Construct the exploit node.
        
        @param exploit: callable(**data) -> boolean
            The exploit that is for this entry.
        @param locator: callable(*path, exploit, **data) -> Exploit|None
            The locator to use for the root entry.
            
            @param path: arguments[object]
                The path elements used in locating the exploit nodes.
            @param exploit: Exploit
                The exploit node used for locating the child nodes in.
            @param data: key arguments
                Additional data that might be used by the locator.
            @return: Exploit|None
                The exploit node that reflect the located path, None if the path is not pointing to a valid node.
                
        @param status: integer
            The status flags for the exploit node.
            
        @ivar children: dictionary{object, Exploit}
            The child exploit nodes.
        '''
        assert exploit is None or callable(exploit), 'Invalid exploit %s' % exploit
        assert locator is None or callable(locator), 'Invalid locator %s' % locator
        assert isinstance(status, int), 'Invalid status flag %s' % status

        self.exploit = exploit
        self.locator = locator
        self.status = status

        self.children = {}

    def add(self, path, exploit):
        '''
        Add a new exploit node, overriding any existing node for the path.
        
        @param path: object
            The path object that represents the node.
        @param exploit: Exploit
            The exploit node to add.
        @return: Exploit
            The newly added exploit, for chaining purposes.
        '''
        assert isinstance(exploit, Exploit), 'Invalid exploit node %s' % exploit

        self.children[path] = exploit
        return exploit

    def get(self, path):
        '''
        Provides the exploit node for path if there is one.
        
        @param path: object
            The path object to get the exploit node for.
        @return: Exploit|None
            The exploit node for the path or None if there is no such node.
        '''
        return self.children.get(path)

    # ----------------------------------------------------------------

    def __setitem__(self, path, exploit):
        '''
        Add a new exploit node, overriding any existing node for the path.
        
        @param path: object
            The path object that represents the node.
        @param exploit: Exploit
            The exploit node to add.
        '''
        assert isinstance(exploit, Exploit), 'Invalid exploit node %s' % exploit

        self.children[path] = exploit

    def __getitem__(self, path):
        '''
        Get the exploit node for path.
        
        @param path: object
            The path object to get the exploit node for.
        @return: Exploit
            The exploit node for the path.
        '''
        return self.children[path]

    def __contains__(self, path):
        '''
        Checks if there is an exploit node for path.
        
        @param path: object
            The path object to check if it has an exploit node.
        @return: boolean
            True if there is an exploit node for the path object, False otherwise.
        '''
        return path in self.children

# --------------------------------------------------------------------

class Resolve(IResolve):
    '''
    The default resolve implementation.
    '''
    __slots__ = ('exploits', 'requests', 'counts', 'count')

    def __init__(self, root):
        '''
        Construct the resolve for the provided exploit.
        
        @param root: Exploit
            The root exploit of the resolve.
        '''
        assert isinstance(root, Exploit), 'Invalid root exploit %s' % root

        self.exploits = deque()
        self.requests = deque()
        self.counts = deque()
        self.count = 0

        self.exploits.append(root)

    def request(self, *path, **data):
        '''
        @see: IResolve.request
        '''
        assert path, 'At least one path element is required'
        # First we find the locator
        for exploit in self.exploits:
            assert isinstance(exploit, Exploit), 'Invalid exploit %s' % exploit
            if exploit.locator is not None:
                locator = exploit.locator
                break
        else: raise ResolveError('No locator available in any exploits')

        exploit = locator(*path, exploit=self.exploits[0], **data)
        if exploit is None or exploit.exploit is None: return False

        self.requests.append((exploit, data))
        self.count += 1

        return True

    def requestBatch(self, *path, data):
        '''
        @see: IResolve.requestBatch
        '''

    def has(self):
        '''
        @see: IResolve.has
        '''
        return self.count > 0

    def do(self):
        '''
        @see: IResolve.do
        '''
        if self.count == 0: return False

        self.count -= 1
        exploit, data = self.requests.popleft()

        assert isinstance(exploit, Exploit), 'Invalid exploit %s' % exploit
        assert callable(exploit.exploit), 'Invalid exploit call %s' % exploit.exploit

        self.exploits.appendleft(exploit)
        self.counts.appendleft(self.count)
        self.count = 0

        if 'resolve' not in data: data['resolve'] = self # Adding the self resolve if none is specified
        if not exploit.exploit(**data):
            self.requests.clear()
            self.counts.clear()
            self.count = 0
            while len(self.exploits) > 1: self.exploits.popleft()
            return False

        self.exploits.popleft()
        count = self.counts.popleft()
        if self.count > 0 and count > 0: self.requests.rotate(self.count)
        self.count += count
        return True

    def doAll(self):
        '''
        @see: IResolve.doAll
        '''
        valid = False
        while self.has():
            if self.do(): valid = True
            else: return False

        return valid

def locatorNormal(status=NORMAL):
    '''
    The normal locator.
    
    @param status: integer
        The status considered valid for the exploit entries searched by this locator.
    '''
    assert isinstance(status, int), 'Invalid status %s' % status

    def locator(*path, exploit, **data):
        assert isinstance(exploit, Exploit), 'Invalid exploit node %s' % exploit

        children = exploit.children
        for key in path:
            exploit = children.get(key)
            if not exploit: return
            if not (exploit.status & status): return # The status doesn't match
            children = exploit.entries

        return exploit
    return locator

def locatorIn(delegateLocator, path):
    '''
    Locator that first finds if the provided exploit has the path and then delegate the locator foe the path exploit.
    
    @param delegateLocator: callable(*path, exploit, **data) -> Exploit|None
        The locator call to delegate with the path exploit.
    @param path: object
        The path object to locate in.
    '''
    assert callable(delegateLocator), 'Invalid locator delegate %s' % delegateLocator

    def locator(*paths, exploit, **data):
        assert isinstance(exploit, Exploit), 'Invalid exploit node %s' % exploit
        exploit = exploit.children.get(path)
        if exploit is None: return

        return delegateLocator(*paths, exploit=exploit, **data)
    return locator
